<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>AI 채팅 + 음성 데모</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f3f4f6;
      color: #333;
      margin: 0;
      padding: 2em;
      display: flex;
      justify-content: center;
    }

    .chat-container {
      width: 100%;
      max-width: 720px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.1);
      padding: 2em;
      display: flex;
      flex-direction: column;
      gap: 1em;
    }

    #status {
      padding: 0.5em 1em;
      background: #eef2ff;
      border-left: 4px solid #6366f1;
      border-radius: 4px;
      font-size: 0.9em;
      font-weight: 500;
    }

    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1em;
    }

    #character-select {
      flex: 1;
      padding: 0.5em;
      font-size: 1em;
      border-radius: 8px;
      border: 1px solid #ccc;
    }

    #chat-log {
      height: 300px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 1em;
      border-radius: 8px;
      background: #fafafa;
      font-size: 0.95em;
    }

    #input-row {
      display: flex;
      gap: 0.5em;
    }

    #user-input {
      flex: 1;
      padding: 0.75em;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 1em;
    }

    #send-btn {
      background: linear-gradient(135deg, #6366f1, #4f46e5);
      color: white;
      border: none;
      padding: 0.75em 1.5em;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    #send-btn:hover {
      background: linear-gradient(135deg, #4f46e5, #4338ca);
    }

    #audio-player {
      display: none;
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div id="status">[WebSocket 상태: 초기화 대기 중]</div>

    <div class="top-row">
      <select id="character-select">
        <option value="44444444-4444-4444-4444-444444444444">제로</option>
        <option value="11111111-1111-1111-1111-111111111111">하루</option>
        <option value="22222222-2222-2222-2222-222222222222">미야</option>
        <option value="33333333-3333-3333-3333-333333333333">소피아</option>
      </select>
    </div>

    <div id="chat-log"></div>

    <div id="input-row">
      <input id="user-input" type="text" placeholder="메시지를 입력하세요" autocomplete="off" />
      <button id="send-btn">전송</button>
    </div>

    <audio id="audio-player" controls></audio>
  </div>

  <script>
    const ENDPOINT = "localhost:7900"
    const WS_URL = `ws://${ENDPOINT}/ws`;
    const HTTP_URL = `http://${ENDPOINT}/api/v1/chat`;
    const SERVER_MESSAGE_TYPE = "json";
    let sessionId = null;
    let ws = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT = 3;

    const statusBox = document.getElementById('status');
    const chatLog = document.getElementById('chat-log');
    const userInput = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');
    const audioPlayer = document.getElementById('audio-player');
    const characterSelect = document.getElementById('character-select');

    const audioQueue = [];
    let isPlayingAudio = false;
    let serverConfig = null;

    // 서버 설정 확인
    async function checkServerConfig() {
      try {
        const response = await fetch(`${HTTP_URL.replace('/chat', '')}/config`);
        if (response.ok) {
          serverConfig = await response.json();
          console.log("서버 설정:", serverConfig);
          setStatus(`연결됨 (메시지 타입: ${serverConfig.messageType})`);
        }
      } catch (e) {
        console.warn("서버 설정 확인 실패:", e);
      }
    }

    // 바이너리 메시지 파싱 함수
    function parseBinaryMessage(arrayBuffer) {
      try {
        const dataView = new DataView(arrayBuffer);
        let offset = 0;
        
        // 메시지 타입 확인 (1바이트)
        const messageType = dataView.getUint8(offset);
        offset += 1;
        
        if (messageType !== 0x03) { // MESSAGE_TYPE_INTEGRATED
          return null; // 지원하지 않는 메시지 타입
        }
        
        // 세션 ID 읽기
        const sessionIdLength = dataView.getUint32(offset, true); // little-endian
        offset += 4;
        const sessionIdBytes = new Uint8Array(arrayBuffer, offset, sessionIdLength);
        const sessionId = new TextDecoder().decode(sessionIdBytes);
        offset += sessionIdLength;
        
        // 텍스트 읽기
        const textLength = dataView.getUint32(offset, true);
        offset += 4;
        let text = null;
        if (textLength > 0) {
          const textBytes = new Uint8Array(arrayBuffer, offset, textLength);
          text = new TextDecoder().decode(textBytes);
          offset += textLength;
        }
        
        // 오디오 데이터 읽기
        const audioLength = dataView.getUint32(offset, true);
        offset += 4;
        let audioData = null;
        if (audioLength > 0) {
          audioData = new Uint8Array(arrayBuffer, offset, audioLength);
          offset += audioLength;
        }
        
        // 오디오 길이 읽기 (float)
        const audioDuration = dataView.getFloat32(offset, true);
        
        return {
          sessionId,
          text,
          audioData,
          audioLength: audioDuration
        };
      } catch (e) {
        console.error("바이너리 메시지 파싱 오류:", e);
        return null;
      }
    }

    function setStatus(message, isError = false) {
      statusBox.textContent = `[WebSocket 상태] ${message}`;
      statusBox.style.background = isError ? '#fee2e2' : '#eef2ff';
      statusBox.style.borderLeftColor = isError ? '#ef4444' : '#6366f1';
    }

    function playNextAudio() {
      if (audioQueue.length === 0) {
        isPlayingAudio = false;
        audioPlayer.style.display = "none";
        return;
      }
      const blob = audioQueue.shift();
      audioPlayer.src = URL.createObjectURL(blob);
      audioPlayer.style.display = "";
      isPlayingAudio = true;
      audioPlayer.play();
      appendLog(`<i>[오디오 재생]</i>`);
    }

    audioPlayer.onended = () => playNextAudio();

    function appendLog(text) {
      chatLog.innerHTML += `<div>${text}</div>`;
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function connectWebSocket() {
      ws = new WebSocket(sessionId ? `${WS_URL}?sessionId=${sessionId}` : WS_URL);
      ws.binaryType = "arraybuffer";

      ws.onopen = () => {
        setStatus("연결됨");
        reconnectAttempts = 0;
        checkServerConfig();
      };

      ws.onmessage = (event) => {
        if (typeof event.data === "string") {
          try {
            const data = JSON.parse(event.data);
            
            // 세션 ID 처리
            if (data.type === "session_id") {
              sessionId = data.session_id;
              appendLog(`<b>[세션 ID: ${sessionId}]</b>`);
              return;
            }
            
            // 통합 메시지 처리
            if (data.type === "chat") {
              let messageText = "";
              
              // 메시지 타입 확인
              const messageType = data.messageType || "json";
              console.log(`메시지 타입: ${messageType}`);
              
              // 텍스트 메시지가 있는 경우
              if (data.text) {
                messageText += `<b>AI:</b> ${data.text}`;
              }
              
              // 오디오 데이터가 있는 경우
              if (data.audioData) {
                try {
                  // Base64 디코딩
                  const audioBytes = atob(data.audioData);
                  const audioArray = new Uint8Array(audioBytes.length);
                  for (let i = 0; i < audioBytes.length; i++) {
                    audioArray[i] = audioBytes.charCodeAt(i);
                  }
                  
                  const blob = new Blob([audioArray], { type: `audio/${data.audioFormat || 'wav'}` });
                  audioQueue.push(blob);
                  if (!isPlayingAudio) playNextAudio();
                  
                  messageText += data.text ? " [오디오 포함]" : "<b>AI:</b> [음성 메시지]";
                } catch (e) {
                  console.error("오디오 데이터 파싱 오류:", e);
                  messageText += " [오디오 파싱 오류]";
                }
              }
              
              if (messageText) {
                appendLog(messageText);
              }
              
              // 메타데이터 표시 (개발용)
              if (data.metadata) {
                appendLog(`<small style='color:#666'>[메타데이터: ${JSON.stringify(data.metadata)}]</small>`);
              }
              
              return;
            }
            
            // 기존 텍스트 메시지 처리 (하위 호환성)
            appendLog(`<b>AI:</b> ${event.data}`);
          } catch (e) {
            // JSON 파싱 실패 시 일반 텍스트로 처리
            appendLog(`<b>AI:</b> ${event.data}`);
          }
        } else if (event.data instanceof ArrayBuffer) {
          // 바이너리 메시지 처리
          try {
            // 바이너리 프로토콜 파싱 시도
            const result = parseBinaryMessage(event.data);
            if (result) {
              let messageText = "";
              
              if (result.text) {
                messageText += `<b>AI:</b> ${result.text}`;
              }
              
              if (result.audioData && result.audioData.length > 0) {
                const blob = new Blob([result.audioData], { type: "audio/wav" });
                audioQueue.push(blob);
                if (!isPlayingAudio) playNextAudio();
                
                messageText += result.text ? " [오디오 포함]" : "<b>AI:</b> [음성 메시지]";
              }
              
              if (messageText) {
                appendLog(messageText);
              }
              
              return;
            }
          } catch (e) {
            console.error("바이너리 메시지 파싱 오류:", e);
          }
          
          // 기존 오디오 처리 (하위 호환성)
          const blob = new Blob([event.data], { type: "audio/wav" });
          audioQueue.push(blob);
          if (!isPlayingAudio) playNextAudio();
        }
      };

      ws.onclose = () => {
        setStatus("연결 종료됨", true);
        appendLog("<b>[WebSocket 연결 종료]</b>");
        tryReconnect();
      };

      ws.onerror = () => {
        setStatus("오류 발생", true);
        appendLog("<b>[WebSocket 오류]</b>");
      };
    }

    function tryReconnect() {
      if (reconnectAttempts < MAX_RECONNECT) {
        reconnectAttempts++;
        setStatus(`재연결 시도 중... (${reconnectAttempts}/${MAX_RECONNECT})`, true);
        setTimeout(connectWebSocket, 1000 * reconnectAttempts);
      } else {
        setStatus("재연결 실패. 새로고침 해주세요.", true);
      }
    }

    function sendChat() {
      const msg = userInput.value.trim();
      if (!msg) return;
      appendLog(`<b>나:</b> ${msg}`);
      userInput.value = "";

      const payload = {
        actor: "web_user",
        message: msg,
        action: "chat",
        character_id: characterSelect.value,
        user_id: "bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb"
      };
      if (sessionId) payload.session_id = sessionId;

      fetch(HTTP_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      })
      .then(res => {
        if (!res.ok) {
          appendLog(`<span style='color:red'>[HTTP 오류] 상태코드: ${res.status}</span>`);
          console.error("HTTP 오류", res);
        }
        return res.json();
      })
      .then(data => {
        if (data && data.id) sessionId = data.id;
      })
      .catch(err => {
        appendLog(`<span style='color:red'>[HTTP 오류] ${err}</span>`);
        console.error(err);
      });
    }

    sendBtn.onclick = sendChat;
    userInput.onkeydown = (e) => { if (e.key === "Enter") sendChat(); };

    characterSelect.onchange = () => {
      userInput.value = "";
      chatLog.innerHTML = "";
      appendLog(`<i>[캐릭터 변경됨: ${characterSelect.options[characterSelect.selectedIndex].text}]</i>`);
    };

    connectWebSocket();
  </script>
</body>
</html>
